// This file is part of Substrate.

// Copyright (C) Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: Apache-2.0

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Ensure we're `no_std` when compiling for Wasm.
#![cfg_attr(not(feature = "std"), no_std)]

extern crate alloc;

use alloc::vec::Vec;
use core::marker::PhantomData;
use ethereum_standards::{
	IERC20,
	IERC20::{IERC20Calls, IERC20Events},
};
use pallet_assets::{weights::WeightInfo, Call, Config, TransferFlags};
use pallet_revive::precompiles::{
	alloy::{
		self,
		primitives::IntoLogData,
		sol_types::{Revert, SolCall},
	},
	AddressMapper, AddressMatcher, Error, Ext, Precompile, RuntimeCosts, H160, H256,
};

pub mod foreign_assets;
pub mod migration;
#[cfg(feature = "runtime-benchmarks")]
pub(crate) mod migration_benchmarks;
pub mod permit;
pub mod weights;

#[cfg(test)]
mod foreign_assets_tests;
#[cfg(test)]
mod migration_tests;
#[cfg(test)]
mod mock;
#[cfg(test)]
mod permit_tests;
#[cfg(test)]
mod tests;

pub use foreign_assets::{pallet, pallet::Config as ForeignAssetsConfig, ForeignAssetId};
pub use migration::{MigrateForeignAssetPrecompileMappings, MigrationState};
pub use permit::{
	pallet::Config as PermitConfig, DIGEST_PREFIX_LEN, DOMAIN_SEPARATOR_ENCODED_LEN,
	PERMIT_STRUCT_ENCODED_LEN, PERMIT_TYPEHASH, SECP256K1_N_DIV_2,
};

/// Mean of extracting the asset id from the precompile address.
pub trait AssetIdExtractor {
	type AssetId;
	/// Extracts the asset id from the address.
	fn asset_id_from_address(address: &[u8; 20]) -> Result<Self::AssetId, Error>;
}

/// The configuration of a pallet-assets precompile.
pub trait AssetPrecompileConfig {
	/// The Address matcher used by the precompile.
	const MATCHER: AddressMatcher;

	/// The [`AssetIdExtractor`] used by the precompile.
	type AssetIdExtractor: AssetIdExtractor;
}

/// An `AssetIdExtractor` that stores the asset id directly inside the address.
pub struct InlineAssetIdExtractor;

impl AssetIdExtractor for InlineAssetIdExtractor {
	type AssetId = u32;
	fn asset_id_from_address(addr: &[u8; 20]) -> Result<Self::AssetId, Error> {
		let bytes: [u8; 4] = addr[0..4].try_into().expect("slice is 4 bytes; qed");
		let index = u32::from_be_bytes(bytes);
		Ok(index.into())
	}
}

/// A precompile configuration that uses a prefix [`AddressMatcher`].
pub struct InlineIdConfig<const PREFIX: u16>;

impl<const P: u16> AssetPrecompileConfig for InlineIdConfig<P> {
	const MATCHER: AddressMatcher = AddressMatcher::Prefix(core::num::NonZero::new(P).unwrap());
	type AssetIdExtractor = InlineAssetIdExtractor;
}

/// An `AssetIdExtractor` that maps a local asset id (4 bytes taken from the address) to a foreign
/// asset id.
pub struct ForeignAssetIdExtractor<Runtime, Instance = ()> {
	_phantom: PhantomData<(Runtime, Instance)>,
}

impl<Runtime, Instance: 'static> AssetIdExtractor for ForeignAssetIdExtractor<Runtime, Instance>
where
	Runtime: pallet_assets::Config<Instance>
		+ pallet::Config<ForeignAssetId = <Runtime as pallet_assets::Config<Instance>>::AssetId>
		+ pallet_revive::Config,
{
	type AssetId = <Runtime as pallet_assets::Config<Instance>>::AssetId;
	fn asset_id_from_address(addr: &[u8; 20]) -> Result<Self::AssetId, Error> {
		let bytes: [u8; 4] = addr[0..4].try_into().expect("slice is 4 bytes; qed");
		let index = u32::from_be_bytes(bytes);
		pallet::Pallet::<Runtime>::asset_id_of(index)
			.ok_or(Error::Revert(Revert { reason: "Invalid foreign asset id".into() }))
	}
}

/// A precompile configuration that uses a prefix [`AddressMatcher`].
pub struct ForeignIdConfig<const PREFIX: u16, Runtime, Instance = ()> {
	_phantom: PhantomData<(Runtime, Instance)>,
}

impl<const P: u16, Runtime, Instance: 'static> AssetPrecompileConfig
	for ForeignIdConfig<P, Runtime, Instance>
where
	Runtime: pallet_assets::Config<Instance>
		+ pallet::Config<ForeignAssetId = <Runtime as pallet_assets::Config<Instance>>::AssetId>
		+ pallet_revive::Config,
{
	const MATCHER: AddressMatcher = AddressMatcher::Prefix(core::num::NonZero::new(P).unwrap());
	type AssetIdExtractor = ForeignAssetIdExtractor<Runtime, Instance>;
}

/// An ERC20 precompile with EIP-2612 permit support.
pub struct ERC20<Runtime, PrecompileConfig, Instance = ()> {
	_phantom: PhantomData<(Runtime, PrecompileConfig, Instance)>,
}

impl<Runtime, PrecompileConfig, Instance: 'static> Precompile
	for ERC20<Runtime, PrecompileConfig, Instance>
where
	PrecompileConfig: AssetPrecompileConfig,
	Runtime: crate::Config<Instance> + pallet_revive::Config + permit::Config,
	<<PrecompileConfig as AssetPrecompileConfig>::AssetIdExtractor as AssetIdExtractor>::AssetId:
		Into<<Runtime as Config<Instance>>::AssetId>,
	Call<Runtime, Instance>: Into<<Runtime as pallet_revive::Config>::RuntimeCall>,
	alloy::primitives::U256: TryInto<<Runtime as Config<Instance>>::Balance>,
	alloy::primitives::U256: TryFrom<<Runtime as Config<Instance>>::Balance>,
	<Runtime as pallet_timestamp::Config>::Moment: sp_runtime::traits::UniqueSaturatedInto<u128>,
{
	type T = Runtime;
	type Interface = IERC20::IERC20Calls;
	const MATCHER: AddressMatcher = PrecompileConfig::MATCHER;
	const HAS_CONTRACT_INFO: bool = false;

	fn call(
		address: &[u8; 20],
		input: &Self::Interface,
		env: &mut impl Ext<T = Self::T>,
	) -> Result<Vec<u8>, Error> {
		let asset_id = PrecompileConfig::AssetIdExtractor::asset_id_from_address(address)?.into();
		let contract_addr = H160::from(*address);

		match input {
			// State-changing calls - check read-only
			IERC20Calls::transfer(_) |
			IERC20Calls::approve(_) |
			IERC20Calls::transferFrom(_) |
			IERC20Calls::permit(_)
				if env.is_read_only() =>
				Err(Error::Error(pallet_revive::Error::<Self::T>::StateChangeDenied.into())),

			// ERC20 functions
			IERC20Calls::transfer(call) => Self::transfer(asset_id, call, env),
			IERC20Calls::totalSupply(_) => Self::total_supply(asset_id, env),
			IERC20Calls::balanceOf(call) => Self::balance_of(asset_id, call, env),
			IERC20Calls::allowance(call) => Self::allowance(asset_id, call, env),
			IERC20Calls::approve(call) => Self::approve(asset_id, call, env),
			IERC20Calls::transferFrom(call) => Self::transfer_from(asset_id, call, env),

			// ERC20Permit functions (EIP-2612)
			IERC20Calls::permit(call) => Self::permit(asset_id, contract_addr, call, env),
			IERC20Calls::nonces(call) => Self::nonces(contract_addr, call, env),
			IERC20Calls::DOMAIN_SEPARATOR(_) => Self::domain_separator(contract_addr, env),
		}
	}
}

const ERR_INVALID_CALLER: &str = "Invalid caller";
const ERR_BALANCE_CONVERSION_FAILED: &str = "Balance conversion failed";

impl<Runtime, PrecompileConfig, Instance: 'static> ERC20<Runtime, PrecompileConfig, Instance>
where
	PrecompileConfig: AssetPrecompileConfig,
	Runtime: crate::Config<Instance> + pallet_revive::Config + permit::Config,
	<<PrecompileConfig as AssetPrecompileConfig>::AssetIdExtractor as AssetIdExtractor>::AssetId:
		Into<<Runtime as Config<Instance>>::AssetId>,
	Call<Runtime, Instance>: Into<<Runtime as pallet_revive::Config>::RuntimeCall>,
	alloy::primitives::U256: TryInto<<Runtime as Config<Instance>>::Balance>,
	alloy::primitives::U256: TryFrom<<Runtime as Config<Instance>>::Balance>,
	<Runtime as pallet_timestamp::Config>::Moment: sp_runtime::traits::UniqueSaturatedInto<u128>,
{
	/// Get the caller as an `H160` address.
	fn caller(env: &mut impl Ext<T = Runtime>) -> Result<H160, Error> {
		env.caller()
			.account_id()
			.map(<Runtime as pallet_revive::Config>::AddressMapper::to_address)
			.map_err(|_| Error::Revert(Revert { reason: ERR_INVALID_CALLER.into() }))
	}

	/// Convert a `U256` value to the balance type of the pallet.
	fn to_balance(
		value: alloy::primitives::U256,
	) -> Result<<Runtime as Config<Instance>>::Balance, Error> {
		value
			.try_into()
			.map_err(|_| Error::Revert(Revert { reason: ERR_BALANCE_CONVERSION_FAILED.into() }))
	}

	/// Convert a balance to a `U256` value.
	/// Note this is needed cause From is not implemented for unsigned integer types
	fn to_u256(
		value: <Runtime as Config<Instance>>::Balance,
	) -> Result<alloy::primitives::U256, Error> {
		alloy::primitives::U256::try_from(value)
			.map_err(|_| Error::Revert(Revert { reason: ERR_BALANCE_CONVERSION_FAILED.into() }))
	}

	fn deposit_event(env: &mut impl Ext<T = Runtime>, event: IERC20Events) -> Result<(), Error> {
		let (topics, data) = event.into_log_data().split();
		let topics = topics.into_iter().map(|v| H256(v.0)).collect::<Vec<_>>();
		env.frame_meter_mut().charge_weight_token(RuntimeCosts::DepositEvent {
			num_topic: topics.len() as u32,
			len: topics.len() as u32,
		})?;
		env.deposit_event(topics, data.to_vec());
		Ok(())
	}

	fn transfer(
		asset_id: <Runtime as Config<Instance>>::AssetId,
		call: &IERC20::transferCall,
		env: &mut impl Ext<T = Runtime>,
	) -> Result<Vec<u8>, Error> {
		env.charge(<Runtime as Config<Instance>>::WeightInfo::transfer())?;

		let from = Self::caller(env)?;
		let dest = <Runtime as pallet_revive::Config>::AddressMapper::to_account_id(
			&call.to.into_array().into(),
		);

		let f = TransferFlags { keep_alive: false, best_effort: false, burn_dust: false };
		pallet_assets::Pallet::<Runtime, Instance>::do_transfer(
			asset_id,
			&<Runtime as pallet_revive::Config>::AddressMapper::to_account_id(&from),
			&dest,
			Self::to_balance(call.value)?,
			None,
			f,
		)?;

		Self::deposit_event(
			env,
			IERC20Events::Transfer(IERC20::Transfer {
				from: from.0.into(),
				to: call.to,
				value: call.value,
			}),
		)?;

		Ok(IERC20::transferCall::abi_encode_returns(&true))
	}

	fn total_supply(
		asset_id: <Runtime as Config<Instance>>::AssetId,
		env: &mut impl Ext<T = Runtime>,
	) -> Result<Vec<u8>, Error> {
		use frame_support::traits::fungibles::Inspect;
		env.charge(<Runtime as Config<Instance>>::WeightInfo::total_issuance())?;

		let value =
			Self::to_u256(pallet_assets::Pallet::<Runtime, Instance>::total_issuance(asset_id))?;
		Ok(IERC20::totalSupplyCall::abi_encode_returns(&value))
	}

	fn balance_of(
		asset_id: <Runtime as Config<Instance>>::AssetId,
		call: &IERC20::balanceOfCall,
		env: &mut impl Ext<T = Runtime>,
	) -> Result<Vec<u8>, Error> {
		env.charge(<Runtime as Config<Instance>>::WeightInfo::balance())?;
		let account = call.account.into_array().into();
		let account = <Runtime as pallet_revive::Config>::AddressMapper::to_account_id(&account);
		let value =
			Self::to_u256(pallet_assets::Pallet::<Runtime, Instance>::balance(asset_id, account))?;
		Ok(IERC20::balanceOfCall::abi_encode_returns(&value))
	}

	fn allowance(
		asset_id: <Runtime as Config<Instance>>::AssetId,
		call: &IERC20::allowanceCall,
		env: &mut impl Ext<T = Runtime>,
	) -> Result<Vec<u8>, Error> {
		env.charge(<Runtime as Config<Instance>>::WeightInfo::allowance())?;
		use frame_support::traits::fungibles::approvals::Inspect;
		let owner = call.owner.into_array().into();
		let owner = <Runtime as pallet_revive::Config>::AddressMapper::to_account_id(&owner);

		let spender = call.spender.into_array().into();
		let spender = <Runtime as pallet_revive::Config>::AddressMapper::to_account_id(&spender);
		let value = Self::to_u256(pallet_assets::Pallet::<Runtime, Instance>::allowance(
			asset_id, &owner, &spender,
		))?;

		Ok(IERC20::allowanceCall::abi_encode_returns(&value))
	}

	fn approve(
		asset_id: <Runtime as Config<Instance>>::AssetId,
		call: &IERC20::approveCall,
		env: &mut impl Ext<T = Runtime>,
	) -> Result<Vec<u8>, Error> {
		env.charge(<Runtime as Config<Instance>>::WeightInfo::approve_transfer())?;
		let owner = Self::caller(env)?;
		let spender = call.spender.into_array().into();
		let spender = <Runtime as pallet_revive::Config>::AddressMapper::to_account_id(&spender);

		pallet_assets::Pallet::<Runtime, Instance>::do_approve_transfer(
			asset_id,
			&<Runtime as pallet_revive::Config>::AddressMapper::to_account_id(&owner),
			&spender,
			Self::to_balance(call.value)?,
		)?;

		Self::deposit_event(
			env,
			IERC20Events::Approval(IERC20::Approval {
				owner: owner.0.into(),
				spender: call.spender,
				value: call.value,
			}),
		)?;

		Ok(IERC20::approveCall::abi_encode_returns(&true))
	}

	fn transfer_from(
		asset_id: <Runtime as Config<Instance>>::AssetId,
		call: &IERC20::transferFromCall,
		env: &mut impl Ext<T = Runtime>,
	) -> Result<Vec<u8>, Error> {
		env.charge(<Runtime as Config<Instance>>::WeightInfo::transfer_approved())?;
		let spender = Self::caller(env)?;
		let spender = <Runtime as pallet_revive::Config>::AddressMapper::to_account_id(&spender);

		let from = call.from.into_array().into();
		let from = <Runtime as pallet_revive::Config>::AddressMapper::to_account_id(&from);

		let to = call.to.into_array().into();
		let to = <Runtime as pallet_revive::Config>::AddressMapper::to_account_id(&to);

		let approval_amount = Self::to_balance(call.value)?;
		pallet_assets::Pallet::<Runtime, Instance>::do_transfer_approved(
			asset_id,
			&from,
			&spender,
			&to,
			approval_amount,
		)?;

		Self::deposit_event(
			env,
			IERC20Events::Transfer(IERC20::Transfer {
				from: call.from,
				to: call.to,
				value: call.value,
			}),
		)?;

		Ok(IERC20::transferFromCall::abi_encode_returns(&true))
	}

	// ==================== ERC20Permit Functions (EIP-2612) ====================

	/// Execute the permit call (EIP-2612).
	///
	/// This verifies the signature, consumes the permit (increments nonce),
	/// and sets the approval.
	fn permit(
		asset_id: <Runtime as Config<Instance>>::AssetId,
		verifying_contract: H160,
		call: &IERC20::permitCall,
		env: &mut impl Ext<T = Runtime>,
	) -> Result<Vec<u8>, Error> {
		// Permit operation is more expensive than approve_transfer:
		// - 2+ keccak256 hashes (domain separator, struct hash, digest)
		// - secp256k1 ECDSA recovery
		// - Storage reads (nonce) and writes (nonce increment, approval)
		env.charge(<Runtime as Config<Instance>>::WeightInfo::approve_transfer())?;

		let owner_h160: H160 = call.owner.into_array().into();
		let spender_h160: H160 = call.spender.into_array().into();

		// EIP-2612: spender cannot be the zero address
		if spender_h160.is_zero() {
			return Err(Error::Revert(Revert { reason: "Spender cannot be zero address".into() }));
		}

		// Convert U256 values to byte arrays
		let value_bytes: [u8; 32] = call.value.to_be_bytes();
		let deadline_bytes: [u8; 32] = call.deadline.to_be_bytes();
		let r_bytes: [u8; 32] = call.r.0;
		let s_bytes: [u8; 32] = call.s.0;

		let transaction_outcome = frame_support::storage::with_transaction(|| {
			let result = (|| {
				// Use the permit - this validates deadline, signature, and increments nonce
				permit::Pallet::<Runtime>::use_permit(
					&verifying_contract,
					&owner_h160,
					&spender_h160,
					&value_bytes,
					&deadline_bytes,
					call.v,
					&r_bytes,
					&s_bytes,
				)
				.map_err(|e| {
					let msg = match e {
						permit::pallet::Error::PermitExpired => "Permit expired",
						permit::pallet::Error::InvalidSignature => "Invalid signature",
						permit::pallet::Error::SignerMismatch => "Signer does not match owner",
						permit::pallet::Error::SignatureSValueTooHigh =>
							"Signature s value too high (malleability)",
						permit::pallet::Error::InvalidVValue => "Invalid signature v value",
						permit::pallet::Error::NonceOverflow => "Nonce overflow",
						permit::pallet::Error::InvalidOwner => "Invalid owner address",
					};
					Error::Revert(Revert { reason: msg.into() })
				})?;

				// Set the approval
				let owner_account =
					<Runtime as pallet_revive::Config>::AddressMapper::to_account_id(&owner_h160);
				let spender_account =
					<Runtime as pallet_revive::Config>::AddressMapper::to_account_id(&spender_h160);

				pallet_assets::Pallet::<Runtime, Instance>::do_approve_transfer(
					asset_id,
					&owner_account,
					&spender_account,
					Self::to_balance(call.value)?,
				)?;

				// Emit Approval event
				Self::deposit_event(
					env,
					IERC20Events::Approval(IERC20::Approval {
						owner: call.owner,
						spender: call.spender,
						value: call.value,
					}),
				)?;
				Ok::<_, Error>(())
			})();
			match result {
				Ok(_) => frame_support::storage::TransactionOutcome::Commit(Ok(())),
				Err(e) => {
					log::trace!(target: frame_support::LOG_TARGET, "Call to permit failed: {e:?}");
					frame_support::storage::TransactionOutcome::Rollback(Err(e))
				},
			}
		});

		// permit returns void
		match transaction_outcome {
			Ok(()) => Ok(Vec::new()),
			Err(e) => Err(e),
		}
	}

	/// Get the current nonce for an owner address.
	fn nonces(
		verifying_contract: H160,
		call: &IERC20::noncesCall,
		env: &mut impl Ext<T = Runtime>,
	) -> Result<Vec<u8>, Error> {
		// TODO: Add proper weight for nonces read
		env.charge(<Runtime as Config<Instance>>::WeightInfo::balance())?;

		let owner_h160: H160 = call.owner.into_array().into();
		let nonce = permit::Pallet::<Runtime>::nonce(&verifying_contract, &owner_h160);

		// Convert sp_core::U256 to alloy U256
		let nonce_bytes = nonce.to_big_endian();
		let nonce_alloy = alloy::primitives::U256::from_be_bytes(nonce_bytes);

		Ok(IERC20::noncesCall::abi_encode_returns(&nonce_alloy))
	}

	/// Get the EIP-712 domain separator for this contract.
	fn domain_separator(
		verifying_contract: H160,
		env: &mut impl Ext<T = Runtime>,
	) -> Result<Vec<u8>, Error> {
		// TODO: Add proper weight for domain separator computation
		env.charge(<Runtime as Config<Instance>>::WeightInfo::balance())?;

		let separator = permit::Pallet::<Runtime>::compute_domain_separator(&verifying_contract);
		let separator_alloy: alloy::primitives::FixedBytes<32> = separator.0.into();

		Ok(IERC20::DOMAIN_SEPARATORCall::abi_encode_returns(&separator_alloy))
	}
}
